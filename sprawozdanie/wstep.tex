\section{Wstęp: }
\subsection{Algorytm Tabu Search}
  Algorytm Tabu Search jest metaheurystyką opierającą się na przeszukiwaniu przestrzeni
  stworzonej ze wszystkich możliwych rozwiązań, za pomocą sekwencji ruchów. Istotą ów algorytmu 
  jest istnienie ruchów niedozwolonych (czyli ruchów tabu). Dzięki swojej strukturze algorytm
  unika ciągłego rozpatrywania jednego optimum lokalnego. \\
  Nasza implementacja przewiduje dwa sposoby determinowania sąsiedztwa: poprzez ruchy
  \textbf{swap} oraz \textbf{invert}. Ruchy \textbf{swap} polegają na zamienianiu pozycjami
  dwóch miast z danej permutacji, natomiast ruchy typu \textbf{invert} polegają na odwróceniu kolejności
  w jakiej występują wszystkie miasta w danej permutacji między dwoma losowo wybranymi indeksami.\\

 \textbf{Złożoność obliczeniowa: }\\
  Główna pętla algorytmu odbywa się aż do momentu osiągnięcia kryterium zatrzymującego pracę. 
  W naszej implementacji jest to liczba iteracji, która jest podawana przez użytkownika
  w momencie uruchomienia programu. Uznajemy więc, iż liczba iteracji jest liczbą stałą.
  Następnie odbywa się generowanie sąsiedztwa dla obecnej permutacji. Generowanie sąsiedztwa odbywa się w pętli 
  for, której liczba iteracji jest podawana przez użytkownika w momencie uruchomienia programu.Na potrzeby ów analizy
  ustalmy, iż użytkownik generuje liczbę sąsiadów równą liczbie miast dla danej instancji (jest to zalecane rozwiązanie dla większych instancji). Po dokonaniu powyższego założenia 
  zauważamy, iż pojedyncza realizacja funkcji generującej sąsiadów wykonuje się w czasie liniowym (podobnie jak w poprzednim zadaniu, wbudowana funkcja \textit{reverse}
  w języku python wykonuje się w \textbf{czasie liniowym}, poza ów funkcją wykonywane są jedynie takie operacje jak losowanie, o stałym czasie realizacji, czy kopiowanie tablicy, które 
  również jest realizowane w czasie liniowym). Ostatecznie wnioskujemy, iż złożoność obliczeniowa funkcji \textit{get neighbors} wynosi $O(n^{2})$.
  Następnie dochodzi do porównania wyników otrzymanych przez funkcję \textit{fitness} (która jest odwrotnością funkcji kosztu) dla każdego z wygenerowanych sąsiadów.
  Biorąc pod uwagę, iż liczba sąsiadów jest liniowo zależna od liczby miast oraz funkcja \textit{cost} wykonuje się w czasie liniowym, dokonanie sprawdzenia, czy któryś z sąsiadów
  zwraca lepszy wynik niż aktualna permutacja również odbywa się w złożoności $O(n^{2})$. Wszystkie następne operacje wykonywane w głonej pętli to operacje 
  przypisania bądź porównania, które odbywają się w czasie stałym. Dodatkowo funkcja \textit{shuffle} również odbywa się w czasie liniowym.\\
  \textbf{Wniosek:} Funkcja \textit{tabu} realizowana jest w czasie $O(n^{2})$.\\
 \textbf{Złożoność pamięciowa: }\\
  Algorytm w swoim procesie często manewruje permutacjami miast, stąd wiemy, iż złożoność pamięciowa jest liniowo zależna od liczby miast. Jedynym wyjątkiem
  jest lista sąsiadów (gdzie w zależności od wprowadzonych przez użytkownika danych trzymamy odpowiednią liczbę permutacji) oraz lista tabu, która również zależy od wprowadzonych
  danych. Oznaczając jako k większą z wartości sąsiedztwa oraz pojemności listy tabu stwierdzamy, iż złożoność pamięciowa funkcji \textit{tabu} wynosi $O(k*n)$
